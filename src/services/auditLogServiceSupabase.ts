/* eslint-disable */
// src/services/auditLogService.ts
import type { Transaction } from 'kysely'
import type { Database } from '../typeDefs/kyselyTypes.js'
import * as gqlTypes from '../typeDefs/gqlTypes.js'
import { logger } from '../logger.js'

type InsertAuditLog = {
    actionType: gqlTypes.ActionType
    objectType: gqlTypes.ObjectType
    schemaVersion?: gqlTypes.SchemaVersion
    updatedBy: string
    newValue?: unknown
    oldValue?: unknown
}

/**
 * Creates an audit log entry within an existing Kysely transaction.
 * This ensures the audit log is created atomically with the main operation.
 * 
 * @param trx - The Kysely transaction to execute within
 * @param params - Audit log parameters
 * @throws If the insert fails (will trigger transaction rollback)
 */
export async function createAuditLog(
    trx: Transaction<Database>,
    {
        actionType,
        objectType,
        updatedBy,
        newValue,
        oldValue,
        schemaVersion = gqlTypes.SchemaVersion.V1
    }: InsertAuditLog
): Promise<void> {
    try {
        await trx
            .insertInto('audit_logs')
            .values({
                action_type: actionType,
                object_type: objectType,
                schema_version: schemaVersion,
                new_value: newValue ? JSON.stringify(newValue) : null,
                old_value: oldValue ? JSON.stringify(oldValue) : null,
                updated_by: updatedBy
                // updated_date is auto-generated by DB (default: now())
            })
            .execute()

        logger.info(`Audit log created: ${actionType} ${objectType}`)
    } catch (error) {
        logger.error(`ERROR: Error creating audit log: ${error}`)
        throw error // Re-throw to trigger transaction rollback
    }
}